import 'grid.dart'; // Import Grid class
import 'node.dart';
import 'pathfinder_base.dart'; // For doc links

/// Provides static utility functions for post-processing paths ([List]<[Node]>)
/// generated by [PathFinder] algorithms.
///
/// Includes methods for compressing paths by removing redundant nodes on straight
/// lines, expanding compressed paths, and smoothing paths using line-of-sight checks.
class PathfindingUtils {

  /// Compresses a path by removing intermediate nodes that lie on a straight
  /// line segment between the previous and next nodes in the path.
  ///
  /// This is useful for reducing the number of waypoints an agent needs to follow,
  /// especially for paths generated on a grid which often contain many collinear nodes.
  /// The start and end nodes of the original path are always preserved.
  ///
  /// Example:
  /// Input Path: `[[0,0], [1,0], [2,0], [3,0], [3,1], [3,2]]`
  /// Output Path: `[[0,0], [3,0], [3,2]]`
  ///
  /// [path] The original list of [Node] objects representing the path, ordered
  ///   from start to end.
  /// Returns a new list containing the compressed path. Returns a copy of the
  ///   original path if it has fewer than 3 nodes.
  static List<Node> compressPath(List<Node> path) {
    // Cannot compress paths with less than 3 nodes
    if (path.length < 3) {
      return List.from(path);
    }

    final compressedPath = <Node>[];
    // Always include the first node
    compressedPath.add(path.first); // Always keep the start node

    // Iterate through the intermediate nodes, comparing segment i-1 -> i with i -> i+1
    for (int i = 1; i < path.length - 1; i++) {
      final prevNode = path[i-1]; // Node before the current one
      final currentNode = path[i];
      final nextNode = path[i + 1];

      // Direction of the segment ending at the current node
      final dx1 = currentNode.x - prevNode.x;
      final dy1 = currentNode.y - prevNode.y;
      // Direction of the segment starting at the current node
      final dx2 = nextNode.x - currentNode.x;
      final dy2 = nextNode.y - currentNode.y;

      // If the direction changes, keep the current node
      if (dx1 != dx2 || dy1 != dy2) {
        compressedPath.add(currentNode);
      }
    }

    // Always include the last node
    // Always include the last node
    if (compressedPath.isEmpty || compressedPath.last != path.last) {
       compressedPath.add(path.last);
    }

    return compressedPath;
  }

  /// Expands a compressed path (containing only key waypoints) by adding back
  /// the intermediate grid nodes that lie on the straight line segments
  /// between the waypoints.
  ///
  /// This is the inverse operation of [compressPath]. It's useful if you need
  /// the full sequence of grid cells for an agent to traverse.
  ///
  /// Example:
  /// Input Path: `[[0,0], [3,0], [3,2]]`
  /// Output Path: `[[0,0], [1,0], [2,0], [3,0], [3,1], [3,2]]`
  ///
  /// [path] The compressed list of [Node] waypoints (ordered start to end).
  /// [grid] The [Grid] instance, needed to retrieve the actual [Node] objects
  ///   for the intermediate points.
  /// Returns a new list containing the fully expanded path including all
  ///   intermediate nodes. Returns a copy of the original path if it has
  ///   fewer than 2 nodes.
  static List<Node> expandPath(List<Node> path, Grid grid) {
    // Cannot expand paths with less than 2 nodes
    if (path.length < 2) {
      return List.from(path);
    }

    final expandedPath = <Node>[];
    // Always add the first node
    expandedPath.add(path.first);

    // Iterate through the segments defined by the compressed path
    for (int i = 0; i < path.length - 1; i++) {
      final nodeA = path[i]; // Start of the segment
      final nodeB = path[i + 1]; // End of the segment

      // Calculate the direction and number of steps for interpolation
      final dx = nodeB.x - nodeA.x;
      final dy = nodeB.y - nodeA.y;
      final steps = dx.abs() > dy.abs() ? dx.abs() : dy.abs(); // Max steps along axis

      // Avoid division by zero if nodes are identical (shouldn't happen in valid path)
      if (steps == 0) continue;

      // Calculate step increments for x and y
      final stepX = dx ~/ steps; // Integer division gives direction (-1, 0, or 1)
      final stepY = dy ~/ steps; // Integer division gives direction (-1, 0, or 1)

      // Interpolate intermediate nodes along the segment
      int currentX = nodeA.x + stepX;
      int currentY = nodeA.y + stepY;
      for (int j = 1; j < steps; j++) {
        try {
          // Retrieve the actual Node object from the grid
          expandedPath.add(grid.getNodeAt(currentX, currentY));
        } catch (e) {
          // Handle cases where intermediate node might be out of bounds
          // (shouldn't happen if compressed path is valid for the grid)
          // print("Warning: Expanding path encountered out-of-bounds node at ($currentX, $currentY)");
        }
        currentX += stepX;
        currentY += stepY;
      }

      // Add the end node of the segment (nodeB)
      // Check if it's different from the last added node to avoid duplicates
      // if nodeA and nodeB were adjacent in the original full path.
      if (expandedPath.last != nodeB) {
         expandedPath.add(nodeB);
      }
    }

    // The process should inherently avoid duplicates except potentially if the
    // original path had only two nodes. A final unique check might be overly cautious.
    // Let's rely on the loop logic.

    return expandedPath;
  }


  /// Smoothens a path by removing intermediate nodes where a direct line-of-sight
  /// exists between the previous "kept" node and a subsequent node further down the path.
  ///
  /// This algorithm attempts to create visually straighter paths by "cutting corners"
  /// where possible, as long as the direct line between two non-consecutive path
  /// nodes doesn't pass through any unwalkable grid cells.
  ///
  /// It iterates through the path, keeping the current node and then checking
  /// line-of-sight to subsequent nodes (`i+2`, `i+3`, ...). It finds the furthest
  /// node (`j`) that still has line-of-sight from the current node (`i`). All nodes
  /// between `i` and `j` are skipped, and the node `j` becomes the next node added
  /// to the smoothed path. The process repeats from node `j`.
  ///
  /// **Note:** It's generally recommended to run this on an **expanded** path
  /// (after using [expandPath] if the path was compressed) to ensure the
  /// line-of-sight check considers all intermediate grid cells accurately.
  ///
  /// [grid] The [Grid] used for walkability checks during line-of-sight calculation.
  /// [path] The list of [Node] objects representing the path (ordered start to end).
  /// Returns a new list containing the smoothed path. Returns a copy of the
  ///   original path if it has fewer than 3 nodes.
  static List<Node> smoothenPath(Grid grid, List<Node> path) {
     // Cannot smooth paths with less than 3 nodes
     if (path.length < 3) {
      return List.from(path);
    }

    final smoothPath = <Node>[path.first]; // Start with the first node
    int currentIndex = 0; // Index of the last node added to smoothPath

    while (currentIndex < path.length - 1) {
      final currentNode = path[currentIndex];
      int nextVisibleIndex = currentIndex + 1; // Start by assuming the next node is the furthest visible

      // Look ahead from the node after the next one
      for (int testIndex = currentIndex + 2; testIndex < path.length; testIndex++) {
        // Check line-of-sight from the last kept node (currentNode) to the test node
        if (_hasLineOfSight(grid, currentNode, path[testIndex])) {
          // Line-of-sight exists, this node is potentially reachable directly
          nextVisibleIndex = testIndex;
        } else {
          // Line-of-sight blocked, the previous 'nextVisibleIndex' was the furthest reachable
          break;
        }
      }
      // Add the furthest visible node found
      smoothPath.add(path[nextVisibleIndex]);
      // Jump the current index to the node just added
      currentIndex = nextVisibleIndex;
    }

    return smoothPath;
  }

  /// Internal helper: Checks if there is a direct, unobstructed line-of-sight
  /// between two nodes on the grid.
  ///
  /// Uses Bresenham's line algorithm (or a similar grid traversal algorithm)
  /// to iterate through all grid cells that lie on the straight line segment
  /// connecting `nodeA` and `nodeB`. If any of these intermediate cells are
  /// unwalkable (checked using `grid.isWalkableAt`), it returns `false`.
  ///
  /// [grid] The grid to check against.
  /// [nodeA] The starting node of the line segment.
  /// [nodeB] The ending node of the line segment.
  /// Returns `true` if all intermediate cells on the line are walkable,
  ///   `false` otherwise.
  static bool _hasLineOfSight(Grid grid, Node nodeA, Node nodeB) {
    int x0 = nodeA.x;
    int y0 = nodeA.y;
    final int x1 = nodeB.x; // Use final for end coordinates
    final int y1 = nodeB.y;

    final int dx = (x1 - x0).abs();
    final int dy = -(y1 - y0).abs(); // Use negative dy for standard Bresenham setup
    final int sx = (x0 < x1) ? 1 : -1; // Step direction for x
    final int sy = (y0 < y1) ? 1 : -1; // Step direction for y
    int err = dx + dy; // Initial error value
    int prevX = x0; // Store previous position to detect diagonal move
    int prevY = y0;

    while (true) {
      // Check the current cell (x0, y0) for walkability *only if* it's not the start or end node.
      final bool isStartNode = (x0 == nodeA.x && y0 == nodeA.y);
      final bool isEndNode = (x0 == x1 && y0 == y1);

      if (!isStartNode && !isEndNode) {
         if (!grid.isWalkableAt(x0, y0)) {
           return false; // Direct obstacle
         }
        // Check for diagonal corner cutting
        if (x0 != prevX && y0 != prevY) { // Moved diagonally since last check
           if (!grid.isWalkableAt(prevX, y0) || !grid.isWalkableAt(x0, prevY)) {
              // If either of the cells forming the corner of the diagonal move is blocked
              return false;
           }
        }
      }

      if (x0 == x1 && y0 == y1) break; // Reached the end

      prevX = x0; // Update previous position before calculating next step
      prevY = y0;

      final int e2 = 2 * err;
      if (e2 >= dy) {
        if (x0 == x1) break;
        err += dy;
        x0 += sx;
      }
      if (e2 <= dx) {
        if (y0 == y1) break;
        err += dx;
        y0 += sy;
      }
    }
    return true; // No obstacles found
  }
}
